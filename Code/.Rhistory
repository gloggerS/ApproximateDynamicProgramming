plot(retPlot[,2], type = "l", ylim = ylim, col = cols[1], main = d, xlab = "Date", ylab = "Value", xaxt='n')
for(i in 3:ncol(retPlot)){
par(new=T)
plot(retPlot[,i], type = "l", ylim = ylim, axes = F, xlab = "", ylab = "", col = cols[i-1])
}
axis(1, at = c(0, 10, 20, 30, 40, 50), labels = retPlot[c(0, 10, 20, 30, 40, 50)+1,1])
legend("bottomright", legend = names(xClassicConst[[d]]), col = cols, lty = 1)
dev.off()
}
# install.packages("tidyr")
library(tidyr)
wholeAnalysis(xClassicVar, "Classic")
wholeAnalysis(xClassicVarNoRf, "Classic-No-Risk-Free")
wholeAnalysis(xDispVarEval, "Sentix-Dispersion")
wholeAnalysis(xHerfVarEval, "Sentix-Herfindahl")
wholeAnalysis(xDispNoRFVarEval, "Sentix-Disperion-No-Risk-Free")
wholeAnalysis(xHerfNoRFVarEval, "Sentix-Herfindahl-No-Risk-Free")
xIndexEval <- list()
for(t in datesEvalNames){
for(p in colnames(ret)){
tmp <- matrix(0, ncol = ncol(ret), nrow = length(get(t))-1)
colnames(tmp) <- colnames(ret)
rownames(tmp) <- get(t)[1:(length(get(t))-1)]
tmp[,which(colnames(ret) == p)] <- 1
xIndexEval[[t]][[p]]$x <- tmp
}
}
wholeAnalysis(xIndexEval, "Indices")
retPortClassicVarying <- calcEvalVarClassic(xClassicVar)
retPortSentixVarying <- calcEvalVarClassic(xDispVarEval)
retAllVarying <- retPortClassicVarying
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortSentixVarying[[timeWindowName]])
}
plotPortfolioComplete(retAllVarying, "Performance-All-classicWithRiskFree")
plotPortfolioComplete(retAllVarying, "Performance-All-classicWithRiskFree", bw=T)
summaryClassicComplete(retAllVarying, "SummaryAll-classicWithRiskFree")
retPortClassicVarying <- calcEvalVarClassic(xClassicVarNoRf)
retPortSentixVarying <- calcEvalVarClassic(xDispNoRFVarEval)
retAllVarying <- retPortClassicVarying
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortSentixVarying[[timeWindowName]])
}
plotPortfolioComplete(retAllVarying, "Performance-All-classicNoRiskFree")
summaryClassicComplete(retAllVarying, "SummaryAll-classicNoRiskFree")
rm(retPortClassicVarying, retPortSentixVarying, retAllVarying)
# install.packages("PeerPerformance")
library(PeerPerformance)
printSharpeRatioComparison <- function(datSent, datClas, fileName){
lateximport <- c(paste0("\\subsection{",fileName," - p-Values that sharpe of Row is not higher}"))
sentCalc <- calcEvalVarClassic(datSent)
clasCalc <- calcEvalVarClassic(datClas)
for(timeWindowName in names(sentCalc)){
lateximport <- c(lateximport, paste0("\\subsubsection{", timeWindowName, "}"))
mat <- matrix(NA, nrow = length(names(sentCalc[[timeWindowName]])),
ncol = length(names(clasCalc[[timeWindowName]])))
rownames(mat) <- names(sentCalc[[timeWindowName]])
colnames(mat) <- names(clasCalc[[timeWindowName]])
for(portfolioName in names(sentCalc[[timeWindowName]])){
rSent <- sentCalc[[timeWindowName]][[portfolioName]]$R
for(portfolioName2 in names(clasCalc[[timeWindowName]])){
rClas <- clasCalc[[timeWindowName]][[portfolioName2]]$R
mat[which(names(sentCalc[[timeWindowName]]) == portfolioName),
which(names(clasCalc[[timeWindowName]]) == portfolioName2)] <- round(sharpeTesting(rSent, rClas)$pval, 4)
}
}
lateximport <- c(lateximport, print(xtable(mat), floating = FALSE))
print(mat)
}
lateximport <- c(lateximport, "\\clearpage")
fileConnection <- file(file.path(getwd(), "Plot", paste0("0SharpeRatioComparison-",fileName,".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
printSharpeRatioComparison(xDispVarEval, xClassicVar, "Dispersion")
printSharpeRatioComparison(xHerfVarEval, xClassicVar, "Herfindahl")
library(PerformanceAnalytics)
library(ggplot2)
library(xtable)
library(PeerPerformance)
costTrade = 0.0002
calcEvalVarClassicTradCost <- function(dat){
res <- list()
for(timeWindowName in names(dat)){
timeWindow <- get(timeWindowName)
retTimeWindow <- ret[timeWindow,]
colnames(retTimeWindow) <- colnames(ret)
# stocks2 <- as.matrix(stocks[,2:ncol(stocks)])
# rownames(stocks2) <- stocks[, 1]
# stocksTimeWindow <- stocks2[timeWindow,]
# rf <- mean(retTimeWindow[,"BUND"])
for(portfolioName in names(dat[[timeWindowName]])){
# CALCULATION OF R FIRST TRY
# turnoverStocks <- abs(diff(dat[[timeWindowName]][[portfolioName]]$x))
# turnoverStocks <- rbind(turnoverStocks, 0) # on last day, no turnover (keep portfolio)
#
# costsTransact <- rowSums(stocksTimeWindow[-1,]*turnoverStocks*costTrade)
# costsTransact <- c(0, costsTransact) # no costs for setting up portfolio
#
# valuePort_Start <- rowSums(dat[[timeWindowName]][[portfolioName]]$x*stocksTimeWindow[-nrow(stocksTimeWindow),]) # start of day
# valuePort_End <- rowSums(dat[[timeWindowName]][[portfolioName]]$x*stocksTimeWindow[-1,]) # end of day
#
# R <- (valuePort_End)/(valuePort_Start)-1 ## returns without Trading Costs
# R <- (valuePort_End - cumsum(costsTransact[-1]))/(valuePort_Start - cumsum(costsTransact[-length(costsTransact)]))-1 ## returns with Trading Costs at end of period
# R <- (valuePort_End - c(0, cumsum(costsTransact[-c(1, length(costsTransact))])))/(valuePort_Start - c(0,0, cumsum(costsTransact[-c(1, length(costsTransact)-1, length(costsTransact))])))-1 ## returns with Trading Costs at start of period
# R NEW VERSION; SHOULD BE CORRECT (COMPARE TO MAIL 8.11.)
## no transaction costs
# R <- numeric(length(timeWindow)-1)
# R <- rowSums(dat[[timeWindowName]][[portfolioName]]$x*(1+retTimeWindow[-1,]))/1-1
## with transaction costs (at start of period)
turnoverStocks <- rowSums(abs(diff(dat[[timeWindowName]][[portfolioName]]$x)))
R <- numeric(length(timeWindow)-1)
R <- (rowSums(dat[[timeWindowName]][[portfolioName]]$x*(1+retTimeWindow[-1,])) - c(0, turnoverStocks)*costTrade)/1 - 1
turnover <- c(0, rowSums(abs(diff(dat[[timeWindowName]][[portfolioName]]$x)))/2) # start off with 0 to have same length
VaR <- VaR(R, method = "historical")
ES <- ES(R, method = "historical")
r <- mean(R)
sd <- sd(R)
anR <- (1+r)^52-1
anSd <- sqrt((sd^2)*52)
omega <- Omega(R)
cVaR <- CVaR(R)
res[[timeWindowName]][[portfolioName]] <- list(x = dat[[timeWindowName]][[portfolioName]]$x,
R = R, r = r, sd = sd, sr = r/sd,
anR = anR, anSd = anSd, anSR = anR/anSd,
turnover = turnover, VaR = VaR, ES = ES,
omega = omega, cVaR = cVaR)
}
}
return(res)
}
calcEvalVarSentixTradCost <- function(dat){
res <- calcEvalVarClassicTradCost(dat)
for(timeWindowName in names(dat)){
for(portfolioName in names(dat[[timeWindowName]])){
fweight = mean(dat[[timeWindowName]][[portfolioName]]$obj)
res[[timeWindowName]][[portfolioName]]$fweight <- fweight
}
}
return(res)
}
wholeAnalysisTradCost <- function(dat, fileName){
retDat <- calcEvalVarClassicTradCost(dat)
# weights
plotWeightsLinesWithTurnoverComplete(retDat, paste0("-adoptedTradingCosts-Weights-", fileName))
# performance of portfolio
plotPortfolioComplete(retDat, paste0("-adoptedTradingCosts-Performance-", fileName))
# summary statistics
summaryClassicComplete(retDat, paste0("-adoptedTradingCosts-Summary-", fileName))
}
wholeAnalysisTradCost(xClassicVar, "Classic")
wholeAnalysisTradCost(xClassicVarNoRf, "Classic-No-Risk-Free")
wholeAnalysisTradCost(xDispVarEval, "Sentix-Dispersion")
wholeAnalysisTradCost(xHerfVarEval, "Sentix-Herfindahl")
wholeAnalysisTradCost(xDispNoRFVarEval, "Sentix-Disperion-No-Risk-Free")
wholeAnalysisTradCost(xHerfNoRFVarEval, "Sentix-Herfindahl-No-Risk-Free")
xIndexEval <- list()
for(t in datesEvalNames){
for(p in colnames(ret)){
tmp <- matrix(0, ncol = ncol(ret), nrow = length(get(t))-1)
colnames(tmp) <- colnames(ret)
rownames(tmp) <- get(t)[1:(length(get(t))-1)]
tmp[,which(colnames(ret) == p)] <- 1
xIndexEval[[t]][[p]]$x <- tmp
}
}
wholeAnalysisTradCost(xIndexEval, "Indices")
retPortClassicVarying <- calcEvalVarClassicTradCost(xClassicVar)
retPortSentixVarying <- calcEvalVarClassicTradCost(xDispVarEval)
retAllVarying <- retPortClassicVarying
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortSentixVarying[[timeWindowName]])
}
plotPortfolioComplete(retAllVarying, "Performance-All-classicWithRiskFree")
summaryClassicComplete(retAllVarying, "SummaryAll-classicWithRiskFree")
retPortClassicVarying <- calcEvalVarClassicTradCost(xClassicVarNoRf)
retPortSentixVarying <- calcEvalVarClassicTradCost(xDispNoRFVarEval)
retAllVarying <- retPortClassicVarying
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortSentixVarying[[timeWindowName]])
}
plotPortfolioComplete(retAllVarying, "Performance-All-classicNoRiskFree")
summaryClassicComplete(retAllVarying, "SummaryAll-classicNoRiskFree")
# rm(retPortClassicVarying, retPortSentixVarying, retAllVarying)
# install.packages("PeerPerformance")
library(PeerPerformance)
printSharpeRatioComparison <- function(datSent, datClas, fileName){
lateximport <- c(paste0("\\subsection{",fileName," - p-Values that sharpe of Row is not higher}"))
sentCalc <- calcEvalVarClassicTradCost(datSent)
clasCalc <- calcEvalVarClassicTradCost(datClas)
for(timeWindowName in names(sentCalc)){
lateximport <- c(lateximport, paste0("\\subsubsection{", timeWindowName, "}"))
mat <- matrix(NA, nrow = length(names(sentCalc[[timeWindowName]])),
ncol = length(names(clasCalc[[timeWindowName]])))
rownames(mat) <- names(sentCalc[[timeWindowName]])
colnames(mat) <- names(clasCalc[[timeWindowName]])
for(portfolioName in names(sentCalc[[timeWindowName]])){
rSent <- sentCalc[[timeWindowName]][[portfolioName]]$R
for(portfolioName2 in names(clasCalc[[timeWindowName]])){
rClas <- clasCalc[[timeWindowName]][[portfolioName2]]$R
mat[which(names(sentCalc[[timeWindowName]]) == portfolioName),
which(names(clasCalc[[timeWindowName]]) == portfolioName2)] <- round(sharpeTesting(rSent, rClas)$pval, 4)
}
}
lateximport <- c(lateximport, print(xtable(mat, digits = 4), floating = FALSE))
print(mat)
}
lateximport <- c(lateximport, "\\clearpage")
fileConnection <- file(file.path(getwd(), "Plot", paste0("0SharpeRatioComparison-",fileName,".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
printSharpeRatioComparison(xDispVarEval, xClassicVar, "Dispersion")
printSharpeRatioComparison(xHerfVarEval, xClassicVar, "Herfindahl")
summaryClassic <- function(datName, d, roundTo = 4){
dat <- datName[[d]]
mat <- matrix(NA, nrow = 6, ncol = length(dat))
rownames(mat) <- c("Mean Return (an)", "Volatility (an)", "Sharpe Ratio (an)", "Omega", "VaR", "CVaR")
colnames(mat) <- names(dat)
for(sInd in 1:length(dat)){
mat[1,sInd] <- round(dat[[sInd]]$anR, roundTo)
mat[2,sInd] <- round(dat[[sInd]]$anSd, roundTo)
mat[3,sInd] <- round(dat[[sInd]]$anSR, roundTo)
mat[4,sInd] <- round(dat[[sInd]]$omega, roundTo)
mat[5,sInd] <- round(dat[[sInd]]$VaR, roundTo)
mat[6,sInd] <- round(dat[[sInd]]$cVaR, roundTo)
}
return(mat)
}
# Code-Schnipsel, wohl nicht vollständig
summaryTableDominik <- function(dat, fileName, roundTo = 4){
lateximport <- c(paste0("\\subsection{",fileName," - summaryTableDominik}"))
datesWeWant <- c("datesEvalBear", "datesEvalRecNBER", "datesEvalBull", "datesEvalAllAfterTest")
tab <- matrix(0, nrow = 6*length(datesWeWant), ncol = 18)
rownames(tab) <- rep(c("Ret. (an)", "Vol. (an)", "SR (an)", "Omega", "VaR", "CoVaR"), 4)
for(d in datesWeWant){
datInside <- dat[[d]]
for(s in names(dat[[d]])){
tab[(which(datesWeWant == d)-1)+1, which(names(dat[[d]]) == s)] = dat[[d]][[s]]$sr
}
tab <- c(lateximport, print(xtable(summaryClassic(dat, d, roundTo)), floating = FALSE))
print(summaryClassic(dat, d, roundTo))
}
lateximport <- c(lateximport, "\\clearpage")
fileConnection <- file(file.path(getwd(), "Plot", paste0("0",fileName,".txt")))
writeLines(lateximport, fileConnection)
close(fileConnection)
}
retPortClassicVarying <- calcEvalVarClassicTradCost(xClassicVar)
retPortSentixVarying <- calcEvalVarClassicTradCost(xDispVarEval)
retPortHerfVarying <- calcEvalVarClassicTradCost(xHerfVarEval)
retAllVarying <- retPortClassicVarying
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortSentixVarying[[timeWindowName]])
}
for(timeWindowName in names(retAllVarying)){
retAllVarying[[timeWindowName]] <- append(retAllVarying[[timeWindowName]], retPortHerfVarying[[timeWindowName]])
}
summaryTableDominik(retAllVarying, "SummaryDominik-classicNoRiskFree")
datesAll
rbinom(3, n = 10, prob = 1/365)
?rbinom
dbinom(3, 10, 1/365)
dbinom(2, 10, 1/365)
1- 365!/(365-23+1)!/365^23
factorial(30)
1- factorial(365)/factorial(365-23+1)/365^23
1-exp(-choose(30, 3)/365^2)
1-exp(-choose(20, 3)/365^2)
setwd("C:\Users\Stefan\LRZ Sync+Share\Masterarbeit-Klein\Code")
setwd("C:/Users/Stefan/LRZ Sync+Share/Masterarbeit-Klein/Code")
require("reticulate")
require("reticulate")
install.packages(require)
install.packages("reticulate")
require("reticulate")
source_python("pickle_reader.py")
pickle_data <- read_pickle_file("C:/Users/Stefan/LRZ Sync+Share/Masterarbeit-Klein/Code/Results/smallTest2-False-DP-190619-1333/totalresults.data")
dat[0]
dat <- read_pickle_file("C:/Users/Stefan/LRZ Sync+Share/Masterarbeit-Klein/Code/Results/smallTest2-False-DP-190619-1333/totalresults.data")
dat[0]
dat$0
dat[[0]]
dat
dat[[1]]
dat[[1]][[1]]
require("ggplot2")
dat[[1]]
tidy_data <- dat[[1]][[1]]
tidy_data
install.packages("data.table")
tidy_data <- rbindlist(dat[[1]])
library(data.table)
tidy_data <- rbindlist(dat[[1]])
dat[[1]]
list(dat[[1]])
d = dat[[1]]
typeof(d)
rbindlist(d)
d[[1]]
typeof(d[[1]])
typeof(data.frame(d[[1]]))
data.frame(d[[1]])
d[[1]]
d[[1]]$value
data.frame(d[[1]]$value, d[[1]]$offer_set_optimal)
data.frame(0, d[[1]]$value)
len(d)
d
length(d)
l = list()
for c in 0:(length(d)-1){
l$c <- data.frame(c, d[[c+1]]$value)
}
l = list()
for c in 0:(length(d)-1){
l[c] <- data.frame(c, d[[c+1]]$value)
}
c
c = 0
c
data.frame(c, d[[c+1]]$value)
l[c]
l = list()
for (c in 0:(length(d)-1)){
l[c] <- data.frame(c, d[[c+1]]$value)
}
l
warnings
warnings()
l = list()
for (c in 0:(length(d)-1)){
l[[c]] <- data.frame(c, d[[c+1]]$value)
}
l = list()
for (c in 1:length(d)){
l[[c]] <- data.frame(c-1, d[[c+1]]$value)
}
l = list()
for (c in 1:length(d)){
l[[c]] <- data.frame(c-1, d[[c]]$value)
}
l
rbindlist(l)
d[[1]]$index
l = list()
for (c in 1:length(d)){
l[[c]] <- data.frame(c-1, d[[c]]$index, d[[c]]$value)
}
d[[c]]$index
int(d[[c]]$index)
numeric(d[[c]]$index)
d[[c]]$index
seq.int(nrow(d[[c]])
)
seq.int(nrow(d[[c]]))-1
l = list()
for (c in 1:length(d)){
l[[c]] <- data.frame(c-1, seq.int(nrow(d[[c]]))-1, d[[c]]$value)
}
rbindlist(l)
l = list()
for (c in 1:length(d)){
l[[c]] <- data.frame("c" = c-1, "t" = seq.int(nrow(d[[c]]))-1, "v" = d[[c]]$value)
}
rbindlist(l)
a = rbindlist(l)
ggplot(a, aes(x=c, y=t, z=v))
d = dat[[1]]
d[[1]]
install.packages("rgl")
library(rgl)
rgl.open()
rgl.points(a$c, a$t, a$v)
install.packages("scatterplot3d")
library(scatterplot3d)
rgl.quit()
plot3d(a$c, a$t, a$v)
library(scatterplot3d)
plot3d(a$c, a$t, a$v)
library(rgl)
open3d()
rgl.open()
library(rgl)
library(reticulate)
library(ggplot2)
library(rgl)
library(scatterplot3d)
library(data.table)
library(reticulate)
library(ggplot2)
library(rgl)
library(scatterplot3d)
library(data.table)
library(reticulate)
library(ggplot2)
library(rgl)
library(scatterplot3d)
library(data.table)
rgl.open()
rgl.points(a$c, a$t, a$v)
a
rgl.surface(a$c, a$t, a$v)
rgl.surface(a$c, a$v, a$t)
rgl.init()
rgl.points(a$c, a$t, a$v)
rgl.close()
rgl.init()
rgl.points(a$c, a$t, a$v)
rgl.init()
rgl.points(a$c, a$t, a$v)
rgl.cur()
rgl.quit()
rgl.open()
library(rgl)
library(plotly)
install.packages("plotly")
library(plotly)
plot_ly(a$c, a$t, a$v, type = "surface")
c <- unique(a$c)
t <- union(a$t)
t <- unique(a$t)
t
c
v <- x %o% t
v <- c %o% t
v
library(tidyverse)
a %>% spread(key = type, value = count)
a
a %>% spread(key = t, value = v)
v <- a %>% spread(key = t, value = v)
v
m <- a %>% spread(key = t, value = v)
matrix(m)
m <- a %>% spread(key = t, value = v)
v <- c %o% t
v <- numeric(m)
v <- data.matrix(m)
v
v <- c %o% t
m
m[-c]
m[-(c)]
m[-"c"]
m <- subset(a, select = -c)
m <- a %>% spread(key = t, value = v)
subset(a, select = -c)
subset(a, select = -"c")
m$c <- NULL
v <- data.matrix(m)
m <- a %>% spread(key = t, value = v)
m$c <- NULL
v <- c %o% t
v <- data.matrix(m)
plot_ly(c, t, v, type = "surface")
plot_ly(a, x = "c", y = "t", type = "surface")
plot_ly(economics, x = ~pop)
plot_ly(a, x = "c", y = "t", z = "v", type = "surface")
plot_ly(economics, x = ~pop)
plot_ly(economics, x = ~date, y = ~pop)
# plot_ly() doesn't require data frame(s), which allows one to take
# advantage of trace type(s) designed specifically for numeric matrices
plot_ly(z = ~volcano)
plot_ly(z = ~volcano, type = "surface")
x <- 1:5/10
y <- 1:5
z <- x %o% y
z <- z + .2*z*runif(25) - .1*z
library(plotly)
plot_ly(x=x,y=y,z=z, type="surface")
z
v
plot_ly(x=c, y=t, z=v, type = "surface")
m <- a %>% spread(key = c, value = v)
m
v <- t %o% c
v <- data.matrix(m)
v <- t %o% c
v <- data.matrix(m)
m <- a %>% spread(key = c, value = v)
m$c <- NULL
m <- a %>% spread(key = c, value = v)
m
m$t <- NULL
v <- t %o% c
v <- data.matrix(m)
plot_ly(x=c, y=t, z=v, type = "surface")
plot_ly(x=c, y=t, z=v, type = "surface", name = "value function")
plot_ly(x=c, y=t, z=v, type = "surface") %>%
layout(xaxis = a)
a <- list(
autotick = FALSE,
ticks = "outside",
tick0 = 0,
dtick = 0.25,
ticklen = 5,
tickwidth = 2,
tickcolor = toRGB("blue")
)
plot_ly(x=c, y=t, z=v, type = "surface") %>%
layout(xaxis = ax)
plot_ly(x=c, y=t, z=v, type = "surface") %>%
layout(xaxis = a)
install.packages("RSelenium")
library(RSelenium)
plot_ly(x=c, y=t, z=v, type = "surface") %>%
export(file = "value_function.svg", selenium = RSelenium::rsDriver(browser = "chrome"))
plot_ly(x=c, y=t, z=v, type = "surface") %>%
export(file = "value_function.svg", selenium = RSelenium::rsDriver(browser = "chrome"))
plot_ly(x=c, y=t, z=v, type = "surface") %>%
orca(file = "value_function.svg", selenium = RSelenium::rsDriver(browser = "chrome"))
